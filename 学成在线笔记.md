---
typora-root-url: 笔记图片
---

学成在线笔记

## 面试相关

ES的使用场景：课程发布的时候，在课程发布代码之后，把课程相关的三个表的信息汇总到一张表里，其中的教学计划内容是转成json串，new出来这个对象后保存到数据库。然后通过logstash将数据库里的该表数据采集到ES中（根据时间戳，只要musql中数据更新或添加了，就采集到ES中）

RabbitMQ使用场景：前提：页面发布的最终目标是将页面发布到服务器。

页面发布的时候，发布成功了给mq发送消息，每个服务器上都部署着的Cms Client(Cms客户端)，这些客户端接收mq的消息，CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。

![1581914085846](G:\张红亮\学成在线\笔记图片\1581914085846.png)

## 第一天

用WebStorm-2018.2.3.exe这个软件打开基础工程，基础工程放在一个目录里：F:/teach/xcEdu/xcEduUI/xc‐ui‐pc‐static‐portal/

安装ngnix，双击exe文件即可启动，访问localhost有欢迎页面，因为默认的端口就是80，打开conf文件夹的配置文件，加入以下配置

```xml
server{
listen 80;
server_name www.xuecheng.com;
ssi on;
ssi_silent_errors on;
location / {
alias F:/teach/xcEdu/xcEduUI/xc‐ui‐pc‐static‐portal/;
index index.html;
}
}
```

然后修改系统C:\Windows\System32\drivers\etc\hosts文件，加入 127.0.0.1 www.xuecheng.com 这个配置

意思是访问www.xuecheng.com这个网址不走外网的cdn解析，直接找这个ip地址即本机地址，然后走工程所在目录的这个项目，即打开网站的门户。

用SSI服务端包含技术实现分类分块管理。

### 

### 14节

我把MongoDB安装在了D:\Program Files\MongoDB\Server\3.4，在bin目录里打开命令行可以通过命令来操作MongoDB，可以看讲义上的一通操作

mongodb插入文档也就是一条数据的时候，如果不指定id，会自动生成一个Objectid

### 19节

创建一个maven工程xc-service-manage-cms ，父工程选择parent，pom文件导入教案里的坐标。

新建好目录结构，新建一个application.yml文件，内容如下

```yaml
server:
	port: 31001
spring:
	application:
		name: xc‐service‐manage‐cms
	data:
		mongodb:
			uri: mongodb://root:123@localhost:27017
			database: xc_cms
```

然后从资料里拷过来logback-spring.xml 日志文件。

在工程目录下新建启动类

```java
@SpringBootApplication
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan(basePackages={"com.xuecheng.api"})//扫描接口
@ComponentScan(basePackages={"com.xuecheng.manage_cms"})//扫描本项目下的所有类
public class ManageCmsApplication {
public static void main(String[] args) {
SpringApplication.run(ManageCmsApplication.class,args);
}
}
```

### 21节

上一节用假数据测通了可以用浏览器访问。这一节主要是通过test文件夹里springboot的单元测试功能测试数据库里的实际数据。

本项目使用Spring Data Mongodb完成Mongodb数据库的查询，Spring Data Mongodb提供一套快捷操作 

mongodb的方法。 

创建Dao，继承MongoRepository，并指定实体类型和主键类型。 （好多方法都不用写，这个自带了好多）

```java
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {
}
```

这是CmsPage实体类

```java
Data
@ToString
@Document(collection = "cms_page")//对于数据库里的这个文档，也就是表
public class CmsPage {
    /**
     * 页面名称、别名、访问地址、类型（静态/动态）、页面模版、状态
     */
    //站点ID
    private String siteId;
    //页面ID
    @Id
    private String pageId;
    //页面名称
    private String pageName;
    //别名
    private String pageAliase;
    //访问地址
    private String pageWebPath;
    //参数
    private String pageParameter;
    //物理路径
    private String pagePhysicalPath;
    //类型（静态/动态）
    private String pageType;
    //页面模版
```

然后就可以在test下编写测试类了，把刚才定义的dao里的接口注入进来就可以直接使用了。注意test下的包路径与main下的包路径保持一致。

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class CmsPageRepositoryTest {
@Autowired
CmsPageRepository cmsPageRepository;
}
```

基础方法测试就是直接用CmsPageRepository里定义好的各种增删改查方法，其中查询的时候会返回一个Optional

关于Optional： 

Optional是jdk1.8引入的类型，Optional是一个容器对象，它包括了我们需要的对象，使用isPresent方法判断所包 

含对象是否为空，isPresent方法返回false则表示Optional包含对象为空，否则可以使用get()取出对象进行操作。 

Optional的优点是： 

1、提醒你非空判断。 

2、将对象非空检测标准化。

还可以在刚才dao里写的那个接口上自定义方法。

![1580969895120](G:\张红亮\学成在线\笔记图片\1580969895120.png)

注意这个Pageable，里面要填上分页数据

## 第二天

vue.js是MVVM模式

![1581050342185](G:\张红亮\学成在线\笔记图片\1581050342185.png)

通过ViewModel可以达到解耦作用

入门程序

![1581050981331](G:\张红亮\学成在线\笔记图片\1581050981331.png)

![1581052752013](G:\张红亮\学成在线\笔记图片\1581052752013.png)

![1581051854337](G:\张红亮\学成在线\笔记图片\1581051854337.png)

v-if,v-for

![1581053344647](G:\张红亮\学成在线\笔记图片\1581053344647.png)

![1581053385393](G:\张红亮\学成在线\笔记图片\1581053385393.png)

![1581053430252](G:\张红亮\学成在线\笔记图片\1581053430252.png)

## 第三天

条件查询

```java
 public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest){
        if (queryPageRequest == null) {
            queryPageRequest = new QueryPageRequest();
        }
        if (page <= 0) {
            page = 1;
        }
        //为了适应mongodb的接口将页码减1
        page = page-1;
        if (size <= 0) {
            size = 20;
        }
//分页对象
        Pageable pageable = PageRequest.of(page,size);
```

```java
 //条件查询
        CmsPage cmsPage = new CmsPage();
        cmsPage.setSiteId(queryPageRequest.getSiteId());
        cmsPage.setPageId(queryPageRequest.getPageId());
        cmsPage.setPageAliase(queryPageRequest.getPageAliase());
        ExampleMatcher exampleMatcher = ExampleMatcher.matching();
        exampleMatcher = exampleMatcher.withMatcher("pageAliase",ExampleMatcher.GenericPropertyMatchers.contains());
        //定义Example
        Example<CmsPage> example = Example.of(cmsPage,exampleMatcher);
        Page<CmsPage> all = cmsPageRepository.findAll(example, pageable);
        QueryResult queryResult = new QueryResult();
        queryResult.setTotal(all.getTotalElements());
        queryResult.setList(all.getContent());
//返回结果
        return new QueryResponseResult(CommonCode.SUCCESS,queryResult);
```

新增

新增时根据三个条件建立唯一索引，用来判断新增的是否已存在，保证数据唯一性



dao层

```java
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {
    //根据页面名称、站点id、页面访问路径查询
    CmsPage findByPageNameAndSiteIdAndPageWebPath(String pageName,String siteId,String pageWebPath);
}
```

service层

```java
//新增页面
    public CmsPageResult add(CmsPage cmsPage){
        //校验页面是否存在，根据页面名称、站点Id、页面webpath查询
        CmsPage cmsPage1 =
                cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(),
                        cmsPage.getSiteId(), cmsPage.getPageWebPath());
        if(cmsPage1==null){
            cmsPage.setPageId(null);//添加页面主键由spring data 自动生成
            cmsPageRepository.save(cmsPage);
        //返回结果
            CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,cmsPage);
            return cmsPageResult;
        }
        return new CmsPageResult(CommonCode.FAIL,null);
    };
```

controller层，记得把传过来的json数据转成对象要用@RequestBody注解

```java
 @Override
    @RequestMapping("/add")
    public CmsPageResult add(@RequestBody CmsPage cmsPage) {
        return pageService.add(cmsPage);
    }
```

修改删除省略见课件

### 可预知异常的统一处理

在common工程下的exception包下新建两个类，新建统一的异常类型类CustomException（为了减小代码侵入性继承RuntimeException）和统一异常捕获类ExceptionCatch

```java
import com.xuecheng.framework.model.response.ResultCode;

/**
 * 自定义异常类型
 * @author Administrator
 * @version 1.0
 * @create 2018-09-14 17:28
 **/
public class CustomException extends RuntimeException {

    //错误代码
    ResultCode resultCode;

    public CustomException(ResultCode resultCode){
        this.resultCode = resultCode;
    }
    public ResultCode getResultCode(){
        return resultCode;
    }


}

```

```java
package com.xuecheng.framework.exception;

/**
 * 统一异常捕获类
 * @author Administrator
 * @version 1.0
 * @create 2018-09-14 17:32
 **/
@ControllerAdvice//控制器增强
public class ExceptionCatch {

    private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class);

    //定义map，配置异常类型所对应的错误代码
    private static ImmutableMap<Class<? extends Throwable>,ResultCode> EXCEPTIONS;
    //定义map的builder对象，去构建ImmutableMap
    protected static ImmutableMap.Builder<Class<? extends Throwable>,ResultCode> builder = ImmutableMap.builder();

    //捕获CustomException此类异常
    @ExceptionHandler(CustomException.class)
    @ResponseBody
    public ResponseResult customException(CustomException customException){
        //记录日志
        LOGGER.error("catch exception:{}",customException.getMessage());
        ResultCode resultCode = customException.getResultCode();
        return new ResponseResult(resultCode);
    }
    //捕获Exception此类异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public ResponseResult exception(Exception exception){
        //记录日志
        LOGGER.error("catch exception:{}",exception.getMessage());
        if(EXCEPTIONS == null){
            EXCEPTIONS = builder.build();//EXCEPTIONS构建成功
        }
        //从EXCEPTIONS中找异常类型所对应的错误代码，如果找到了将错误代码响应给用户，如果找不到给用户响应99999异常
        ResultCode resultCode = EXCEPTIONS.get(exception.getClass());
        if(resultCode !=null){
            return new ResponseResult(resultCode);
        }else{
            //返回99999异常
            return new ResponseResult(CommonCode.SERVER_ERROR);
        }
    }
    static {
        //定义异常类型所对应的错误代码
        builder.put(HttpMessageNotReadableException.class,CommonCode.INVALID_PARAM);
    }
}

```

为了让spring扫描到上述统一处理类，启动类上要加注解

@ComponentScan(basePackages={"com.xuecheng.framework"})//扫描common包下的类

这样就可以在需要抛异常的时候直接抛出去加个错误代码就行了。

### 不可预知异常

思路就是弄一个ImmutableMap，把可能出现的异常放里面去，类型对应着异常码，如果发生异常在这个map里找到这个类型的了，就抛对应的异常码等，如果找不到就统一抛99999.

ImmutableMap：一旦构建不可更改，且为线程安全

## 第四天

![1581310998926](G:\张红亮\学成在线\学成在线笔记.assets\1581310998926.png)

遍历list

![1581312510074](G:\张红亮\学成在线\笔记图片\1581312510074.png)

遍历map

![1581312445549](G:\张红亮\学成在线\笔记图片\1581312445549.png)

if表达式

![1581312813773](G:\张红亮\学成在线\笔记图片\1581312813773.png)

![1581312604320](G:\张红亮\学成在线\笔记图片\1581312604320.png)

空值处理

![1581312907546](G:\张红亮\学成在线\笔记图片\1581312907546.png)

## 第五天 RabbitMQ

![1581394072920](G:\张红亮\学成在线\笔记图片\1581394072920.png)

编写生产者测试程序，新建两个子工程，导入包

![1581394150300](G:\张红亮\学成在线\学成在线笔记.assets\1581394150300.png)

生产者步骤

![1581394194293](G:\张红亮\学成在线\笔记图片\1581394194293.png)

代码

```java
package com.xuecheng.test.rabbitmq;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * rabbitmq的入门程序
 *
 * @author Administrator
 * @version 1.0
 * @create 2018-06-17 9:05
 **/
public class Producer01 {

    //队列
    private static final String QUEUE = "helloworld";

    public static void main(String[] args) {
        //通过连接工厂创建新的连接和mq建立连接
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("127.0.0.1");
        connectionFactory.setPort(5672);//端口
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq
        connectionFactory.setVirtualHost("/");

        Connection connection = null;
        Channel channel = null;
        try {
            //建立新连接
            connection = connectionFactory.newConnection();
            //创建会话通道,生产者和mq服务所有通信都在channel通道中完成
            channel = connection.createChannel();
            //声明队列，如果队列在mq 中没有则要创建
            //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments
            /**
             * 参数明细
             * 1、queue 队列名称
             * 2、durable 是否持久化，如果持久化，mq重启后队列还在
             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建
             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）
             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间
             */
            channel.queueDeclare(QUEUE,true,false,false,null);
            //发送消息
            //参数：String exchange, String routingKey, BasicProperties props, byte[] body
            /**
             * 参数明细：
             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为""）
             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称
             * 3、props，消息的属性
             * 4、body，消息内容
             */
            //消息内容
            String message = "hello world 黑马程序员";
            channel.basicPublish("",QUEUE,null,message.getBytes());
            System.out.println("send to mq "+message);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关闭连接
            //先关闭通道
            try {
                channel.close();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (TimeoutException e) {
                e.printStackTrace();
            }
            try {
                connection.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


    }
}

```

消费者步骤

![1581395718078](G:\张红亮\学成在线\笔记图片\1581395718078.png)

消费者代码

```java
package com.xuecheng.test.rabbitmq;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 入门程序消费者
 * @author Administrator
 * @version 1.0
 * @create 2018-06-17 9:25
 **/
public class Consumer01 {

    //队列
    private static final String QUEUE = "helloworld";

    public static void main(String[] args) throws IOException, TimeoutException {
        //通过连接工厂创建新的连接和mq建立连接
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("127.0.0.1");
        connectionFactory.setPort(5672);//端口
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq
        connectionFactory.setVirtualHost("/");

        //建立新连接
        Connection connection = connectionFactory.newConnection();
        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成
        Channel channel = connection.createChannel();

        //监听队列
        //声明队列，如果队列在mq 中没有则要创建
        //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments
        /**
         * 参数明细
         * 1、queue 队列名称
         * 2、durable 是否持久化，如果持久化，mq重启后队列还在
         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建
         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）
         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间
         */
        channel.queueDeclare(QUEUE,true,false,false,null);

        //实现消费方法
        DefaultConsumer defaultConsumer = new DefaultConsumer(channel){

            /**
             * 当接收到消息后此方法将被调用
             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume
             * @param envelope 信封，通过envelope
             * @param properties 消息属性
             * @param body 消息内容
             * @throws IOException
             */
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                //交换机
                String exchange = envelope.getExchange();
                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收
                long deliveryTag = envelope.getDeliveryTag();
                //消息内容
                String message= new String(body,"utf-8");
                System.out.println("receive message:"+message);
            }
        };

        //监听队列
        //参数：String queue, boolean autoAck, Consumer callback
        /**
         * 参数明细：
         * 1、queue 队列名称
         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复
         * 3、callback，消费方法，当消费者接收到消息要执行的方法
         */
        channel.basicConsume(QUEUE,true,defaultConsumer);

    }
}

```

### rmq的工作模式

![1581405669159](G:\张红亮\学成在线\学成在线笔记.assets\1581405669159.png)

1、Work queues：工作队列模式

![1581405752900](G:\张红亮\学成在线\学成在线笔记.assets\1581405752900.png)

2、发布、订阅模式





![1581406456333](G:\张红亮\学成在线\笔记图片\1581406456333.png)

![1581407374737](G:\张红亮\学成在线\笔记图片\1581407374737.png)

测试：

**在生产者工程里新建类Producer02_publish.java**

代码

```java
package com.xuecheng.test.rabbitmq;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @author Administrator
 * @version 1.0
 * @create 2018-06-17 18:10
 **/
public class Producer02_publish {
    //队列名称
    private static final String QUEUE_INFORM_EMAIL = "queue_inform_email";
    private static final String QUEUE_INFORM_SMS = "queue_inform_sms";
    private static final String EXCHANGE_FANOUT_INFORM="exchange_fanout_inform";

    public static void main(String[] args) {
        //通过连接工厂创建新的连接和mq建立连接
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("127.0.0.1");
        connectionFactory.setPort(5672);//端口
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq
        connectionFactory.setVirtualHost("/");

        Connection connection = null;
        Channel channel = null;
        try {
            //建立新连接
            connection = connectionFactory.newConnection();
            //创建会话通道,生产者和mq服务所有通信都在channel通道中完成
            channel = connection.createChannel();
            //声明队列，如果队列在mq 中没有则要创建
            //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments
            /**
             * 参数明细
             * 1、queue 队列名称
             * 2、durable 是否持久化，如果持久化，mq重启后队列还在
             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建
             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）
             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间
             */
            channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);
            channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);
            //声明一个交换机
            //参数：String exchange, String type
            /**
             * 参数明细：
             * 1、交换机的名称
             * 2、交换机的类型
             * fanout：对应的rabbitmq的工作模式是 publish/subscribe
             * direct：对应的Routing	工作模式
             * topic：对应的Topics工作模式
             * headers： 对应的headers工作模式
             */
            channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT);
            //进行交换机和队列绑定
            //参数：String queue, String exchange, String routingKey
            /**
             * 参数明细：
             * 1、queue 队列名称
             * 2、exchange 交换机名称
             * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串
             */
            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,"");
            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_FANOUT_INFORM,"");
            //发送消息
            //参数：String exchange, String routingKey, BasicProperties props, byte[] body
            /**
             * 参数明细：
             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为""）
             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称
             * 3、props，消息的属性
             * 4、body，消息内容
             */
            for(int i=0;i<5;i++){
                //消息内容
                String message = "send inform message to user";
                channel.basicPublish(EXCHANGE_FANOUT_INFORM,"",null,message.getBytes());
                System.out.println("send to mq "+message);
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //关闭连接
            //先关闭通道
            try {
                channel.close();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (TimeoutException e) {
                e.printStackTrace();
            }
            try {
                connection.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


    }
}

```



![1581406366197](G:\张红亮\学成在线\笔记图片\1581406366197.png)

![1581406774493](G:\张红亮\学成在线\笔记图片\1581406774493.png)



**消费者工程里建两个消费者Consumer02_subscribe_email.java，Consumer02_subscribe_sms.java**

![1581407801146](G:\张红亮\学成在线\笔记图片\1581407801146.png)

3、routing  路由工作模式（能实现发布订阅模式，但是更强大，可以根据key定向的发送给队列）

![1581408279901](G:\张红亮\学成在线\笔记图片\1581408279901.png)

![1581408337844](G:\张红亮\学成在线\笔记图片\1581408337844.png)

测试代码在xxx03xx.java文件中

4、Topoic工作模式（通配符模式）

![1581410387480](G:\张红亮\学成在线\笔记图片\1581410387480.png)

5、RPC模式

![1581411337262](G:\张红亮\学成在线\笔记图片\1581411337262.png)



## 第六天 页面发布 课程管理

![1581487371704](G:\张红亮\学成在线\笔记图片\1581487371704.png)

![1581493091219](G:\张红亮\学成在线\笔记图片\1581493091219.png)

消息消费方的部分代码

![1581489543819](G:\张红亮\学成在线\笔记图片\1581489543819.png)

课程管理

表的自连接实现树状图数据查询

![1581503596623](G:\张红亮\学成在线\笔记图片\1581503596623.png)

mapper.xml文件（注意看resultMap怎么写的，一共有三级，每以及里有个childrenlist，对应着<collection>标签）

```xml
<resultMap id="teachplanMap" type="com.xuecheng.framework.domain.course.ext.TeachplanNode">
        <id column="one_id" property="id"></id>
        <result column="one_pname" property="pname"></result>
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
            <id column="two_id" property="id"></id>
            <result column="two_pname" property="pname"></result>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
                <id column="three_id" property="id"></id>
                <result column="three_pname" property="pname"></result>
            </collection>
        </collection>

    </resultMap>
```

## 第七天  FastDFS

FastDFS工作原理图

![1581567399514](G:\张红亮\学成在线\笔记图片\1581567399514.png)

![1581567434332](G:\张红亮\学成在线\笔记图片\1581567434332.png)

![1581567461416](G:\张红亮\学成在线\笔记图片\1581567461416.png)



![1581567486015](G:\张红亮\学成在线\笔记图片\1581567486015.png)

配置集群

![1581570565270](G:\张红亮\学成在线\笔记图片\1581570565270.png)

## 第九天 Eureka

#### 搭建单机版的Eureka server注册中心

新建一个springboot工程，导入依赖，在启动类上打注解@EnableEurekaServer，然后编写配置文件，一个Eureka注册中心就完成了

```
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring‐cloud‐dependencies</artifactId>
<version>Finchley.SR1</version>
<type>pom</type>
<scope>import</scope>
</dependency>
<dependencies>
<!‐‐ 导入Eureka服务的依赖 ‐‐>
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring‐cloud‐starter‐netflix‐eureka‐server</artifactId>
</dependency>
</dependencies>
```

```java
@EnableEurekaServer//标识这是一个Eureka服务
@SpringBootApplication
public class GovernCenterApplication {
public static void main(String[] args) {
SpringApplication.run(GovernCenterApplication.class, args);
}
}
```

![1581587842482](G:\张红亮\学成在线\笔记图片\1581587842482.png)

```
Eureka Server有一种自我保护模式，当微服务不再向Eureka Server上报状态，Eureka Server会从服务列表将此
服务删除，如果出现网络异常情况（微服务正常），此时Eureka server进入自保护模式，不再将微服务从服务列
表删除。白话就是：服务由于网络波动不发心跳包了，本来应该在服务列表将其移除，但是自我保护机制让它先活着。
在开发阶段建议关闭自保护模式。
```

#### 搭建Eureka Server集群

![1581588724573](G:\张红亮\学成在线\笔记图片\1581588724573.png)

![1581589010758](G:\张红亮\学成在线\笔记图片\1581589010758.png)

设置上面说的传参的方法

![1581589204295](G:\张红亮\学成在线\笔记图片\1581589204295.png)

![1581589337266](G:\张红亮\学成在线\笔记图片\1581589337266.png)

将cms服务注册到注册中心中去

cms导入Eureka Client坐标

```yaml
<!‐‐ 导入Eureka客户端的依赖 ‐‐>
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring‐cloud‐starter‐netflix‐eureka‐client</artifactId>
</dependency>
```

在yml文件中添加如下配置

![1581589853362](G:\张红亮\学成在线\笔记图片\1581589853362.png)

在cms工程启动类上添加注解 @EnableDiscoveryClient ，表示它是一个Eureka的客户端

#### 测试ribbon

模拟course调用cms

course工程引入ribbon坐标

Spring Cloud引入Ribbon配合 restTemplate 实现客户端负载均衡。Java中远程调用的技术有很多，如： 

webservice、socket、rmi、Apache HttpClient、OkHttp等，互联网项目使用基于http的客户端较多，本项目使 

用OkHttp。 

```
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring‐cloud‐starter‐ribbon</artifactId>
</dependency>
<dependency>
<groupId>com.squareup.okhttp3</groupId>
<artifactId>okhttp</artifactId>
</dependency>
```

配置文件中加入ribbon相关

```yaml
ribbon:
	MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试
	MaxAutoRetriesNextServer: 3 #切换实例的重试次数
	OkToRetryOnAllOperations: false #对所有操作请求都进行重试，如果是get则可以，如果是post，put等                                      操作
没有实现幂等的情况下是很危险的,所以设置为false
	ConnectTimeout: 5000 #请求连接的超时时间
	ReadTimeout: 6000 #请求处理的超时时间
```

启动类上添加bena

![1581591894743](G:\张红亮\学成在线\笔记图片\1581591894743.png)

写测试类

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class TestRibbon {
    @Autowired
    RestTemplate restTemplate;

    @Test
    public void testRibbon(){
        //确定要获取的服务名
        String serviceId = "XC-SERVICE-MANAGE-CMS";
        for (int i=0;i<10;i++){
            //ribbon客户端从eurekaServer中获取服务列表,根据服务名获取服务列表
            ResponseEntity<Map> forEntity = restTemplate.getForEntity("http://"+serviceId+"/cms/page/get/5a754adf6abb500ad05688d9", Map.class);
            Map body = forEntity.getBody();
            System.out.println(body);
        }

    }


}
```

#### Feign（像调用本地方法一样调用远程接口）

和ribbon的区别就是要定义一个接口，打上@FeignClient接口，在这个接口写明地址

还是course工程，引入坐标（引入feign就引入了ribbon，已经集成了ribbon）

```
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring‐cloud‐starter‐openfeign</artifactId>
</dependency>
```

找个地写个接口，指定个服务名就行了，测试的时候注入这个接口，spring会为这个接口生成一个feign的代理对象，所以直接用这个接口里的方法调用就可以

```java
package com.xuecheng.manage_course.client;

import com.xuecheng.framework.domain.cms.CmsPage;
import com.xuecheng.framework.domain.cms.response.CmsPageResult;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

/**
 * Created by Administrator.
 */
@FeignClient(value = "XC-SERVICE-MANAGE-CMS") //指定远程调用的服务名
public interface CmsPageClient {
    //根据页面id查询页面信息，远程调用cms请求数据
    @GetMapping("/cms/page/get/{id}")//用GetMapping标识远程调用的http的方法类型
    public CmsPage findCmsPageById(@PathVariable("id") String id);

    //添加页面，用于课程预览
    @PostMapping("/cms/page/save")
    public CmsPageResult saveCmsPage(@RequestBody CmsPage cmsPage);
}

```

**启动类添加@EnableFeignClients注解**

测试

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class FeignTest {
@Autowired
CmsPageClient cmsPageClient;
@Test
public void testFeign() {
//通过服务id调用cms的查询页面接口
CmsPage cmsPage = cmsPageClient.findById("5a754adf6abb500ad05688d9");
System.out.println(cmsPage);
}
}
```

**Feign****注意点** 

SpringCloud对Feign进行了增强兼容了SpringMVC的注解 ，我们在使用SpringMVC的注解时需要注意： 

1、feignClient接口 有参数在参数必须加@PathVariable("XXX")和@RequestParam("XXX") 

2、feignClient返回值为复杂对象时其类型必须有无参构造函数。 

## 第十天 ElasticSearch

1、elasticsearch是一个基于Lucene的高扩展的分布式搜索服务器，支持开箱即用。 

2、elasticsearch隐藏了Lucene的复杂性，对外提供Restful 接口来操作索引、搜索。 

![1581747806585](G:\张红亮\学成在线\笔记图片\1581747806585.png)

#### ES的使用

1、创建索引库（可以通过postman创建也可以通过head插件创建）

ES的索引库是一个逻辑概念，它包括了分词列表及文档列表，同一个索引库中存储了相同类型的文档。它就相当于MySQL中的表，或相当于Mongodb中的集合。 

![1581747717149](G:\张红亮\学成在线\笔记图片\1581747717149.png)

2、创建映射

![1581748061894](G:\张红亮\学成在线\笔记图片\1581748061894.png)



![1581748136012](G:\张红亮\学成在线\笔记图片\1581748136012.png)



3、创建文档

![1581748222719](G:\张红亮\学成在线\笔记图片\1581748222719.png)



![1581748366715](G:\张红亮\学成在线\笔记图片\1581748366715.png)



4、搜索文档

![1581748492498](G:\张红亮\学成在线\笔记图片\1581748492498.png)

![1581748577115](G:\张红亮\学成在线\笔记图片\1581748577115.png)

#### IK分词器

下载好ik分词器后把它解压出来，然后把解压出来的目录放到ES的plugin目录下，重命名为ik，重启ES

![1581748973533](G:\张红亮\学成在线\笔记图片\1581748973533.png)

自定词库

![1581750011441](G:\张红亮\学成在线\笔记图片\1581750011441.png)

要保存成无bom的utf-8格式

![1581749937678](G:\张红亮\学成在线\笔记图片\1581749937678.png)





text类型

![1581750688400](G:\张红亮\学成在线\笔记图片\1581750688400.png)

```
对于ik分词器建议是索引时使用ik_max_word将搜索内容进行细粒度分词，搜索时使用ik_smart提高搜索精确性。
"name": {
"type": "text",
"analyzer":"ik_max_word",
"search_analyzer":"ik_smart"
}
```

![1581751201292](G:\张红亮\学成在线\笔记图片\1581751201292.png)

```
keyword类型是精确匹配
```

上边介绍的text文本字段在映射时要设置分词器，keyword字段为关键字字段，通常搜索keyword是按照整体搜 

索，所以创建keyword字段的索引时是不进行分词的，比如：邮政编码、手机号码、身份证等。keyword字段通常 

用于过虑、排序、聚合等。 

------

```


工程搭建见测试工程代码
```

## 第十一天 搜索服务

搜索流程

![1581907420432](G:\张红亮\学成在线\笔记图片\1581907420432.png)

![1581907443106](G:\张红亮\学成在线\笔记图片\1581907443106.png)

```
课程信息分布在course_base、course_pic等不同的表中。
课程发布成功为了方便进行索引将这几张表的数据合并在一张表中，作为课程发布信息。
创建course_pub表
```

在课程发布的代码里维护一个CoursePub对象，发布以后把这个三个表的综合体对象保存到数据库，通过logstash定时将这个表里的数据采集到ES中

![1581910196926](G:\张红亮\学成在线\笔记图片\1581910196926.png)

搜索的service代码

```java
package com.xuecheng.search.service;

import com.xuecheng.framework.domain.course.CoursePub;
import com.xuecheng.framework.domain.search.CourseSearchParam;
import com.xuecheng.framework.model.response.CommonCode;
import com.xuecheng.framework.model.response.QueryResponseResult;
import com.xuecheng.framework.model.response.QueryResult;
import org.apache.commons.lang3.StringUtils;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.MultiMatchQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;


/**
 * @author Administrator
 * @version 1.0
 **/
@Service
public class EsCourseService {

    @Value("${xuecheng.course.index}")
    private String index;
    @Value("${xuecheng.course.type}")
    private String type;
    @Value("${xuecheng.course.source_field}")
    private String source_field;

    @Autowired
    RestHighLevelClient restHighLevelClient;

    //课程搜索
    public QueryResponseResult<CoursePub> list(int page, int size, CourseSearchParam courseSearchParam) {
        if(courseSearchParam == null){
            courseSearchParam = new CourseSearchParam();
        }
        //创建搜索请求对象
        SearchRequest searchRequest = new SearchRequest(index);
        //设置搜索类型
        searchRequest.types(type);

        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        //过虑源字段
        String[] source_field_array = source_field.split(",");
        searchSourceBuilder.fetchSource(source_field_array,new String[]{});
        //创建布尔查询对象
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        //搜索条件
        //根据关键字搜索
        if(StringUtils.isNotEmpty(courseSearchParam.getKeyword())){
            MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), "name", "description", "teachplan")
                    .minimumShouldMatch("70%")
                    .field("name", 10);
            boolQueryBuilder.must(multiMatchQueryBuilder);
        }
        if(StringUtils.isNotEmpty(courseSearchParam.getMt())){
            //根据一级分类
            boolQueryBuilder.filter(QueryBuilders.termQuery("mt",courseSearchParam.getMt()));
        }
        if(StringUtils.isNotEmpty(courseSearchParam.getSt())){
            //根据二级分类
            boolQueryBuilder.filter(QueryBuilders.termQuery("st",courseSearchParam.getSt()));
        }
        if(StringUtils.isNotEmpty(courseSearchParam.getGrade())){
            //根据难度等级
            boolQueryBuilder.filter(QueryBuilders.termQuery("grade",courseSearchParam.getGrade()));
        }

        //设置boolQueryBuilder到searchSourceBuilder
        searchSourceBuilder.query(boolQueryBuilder);
        searchRequest.source(searchSourceBuilder);

        QueryResult<CoursePub> queryResult = new QueryResult();
        List<CoursePub> list = new ArrayList<>();
        try {
            //执行搜索
            SearchResponse searchResponse = restHighLevelClient.search(searchRequest);
            //获取响应结果
            SearchHits hits = searchResponse.getHits();
            //匹配的总记录数
            long totalHits = hits.totalHits;
            queryResult.setTotal(totalHits);
            SearchHit[] searchHits = hits.getHits();
            for(SearchHit hit:searchHits){
                CoursePub coursePub = new CoursePub();
                //源文档
                Map<String, Object> sourceAsMap = hit.getSourceAsMap();
                //取出name
                String name = (String) sourceAsMap.get("name");
                coursePub.setName(name);
                //图片
                String pic = (String) sourceAsMap.get("pic");
                coursePub.setPic(pic);
                //价格
                Double price = null;
                try {
                    if(sourceAsMap.get("price")!=null ){
                        price = (Double) sourceAsMap.get("price");
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
                coursePub.setPrice(price);
                //旧价格
                Double price_old = null;
                try {
                    if(sourceAsMap.get("price_old")!=null ){
                        price_old = (Double) sourceAsMap.get("price_old");
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                coursePub.setPrice_old(price_old);
                //将coursePub对象放入list
                list.add(coursePub);
            }


        } catch (IOException e) {
            e.printStackTrace();
        }

        queryResult.setList(list);
        QueryResponseResult<CoursePub> queryResponseResult = new QueryResponseResult<CoursePub>(CommonCode.SUCCESS,queryResult);

        return queryResponseResult;
    }
}

```

## 第十三天 流媒体相关

文件的分块和合并轮子代码

```java
package com.xuecheng.manage_media;

import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * @author Administrator
 * @version 1.0
 **/
public class TestFile {



    //测试文件分块
    @Test
    public void testChunk() throws IOException {
        //源文件
        File sourceFile = new File("E:\\ffmpeg_test\\lucene.avi");
        //块文件目录
        String chunkFileFolder = "E:\\ffmpeg_test\\chunks\\";

        //先定义块文件大小
        long chunkFileSize = 1 * 1024 * 1024;

        //块数
        long chunkFileNum = (long) Math.ceil(sourceFile.length() * 1.0 /chunkFileSize);

        //创建读文件的对象
        RandomAccessFile raf_read = new RandomAccessFile(sourceFile,"r");

        //缓冲区
        byte[] b = new byte[1024];
        for(int i=0;i<chunkFileNum;i++){
            //块文件
            File chunkFile = new File(chunkFileFolder+i);
            //创建向块文件的写对象
            RandomAccessFile raf_write = new RandomAccessFile(chunkFile,"rw");
            int len = -1;

            while((len = raf_read.read(b))!=-1){

                raf_write.write(b,0,len);
                //如果块文件的大小达到 1M开始写下一块儿
                if(chunkFile.length()>=chunkFileSize){
                    break;
                }
            }
            raf_write.close();


        }
        raf_read.close();
    }


    //测试文件合并
    @Test
    public void testMergeFile() throws IOException {
        //块文件目录
        String chunkFileFolderPath = "E:\\ffmpeg_test\\chunks\\";
        //块文件目录对象
        File chunkFileFolder = new File(chunkFileFolderPath);
        //块文件列表
        File[] files = chunkFileFolder.listFiles();
        //将块文件排序，按名称升序
        List<File> fileList = Arrays.asList(files);
        Collections.sort(fileList, new Comparator<File>() {
            @Override
            public int compare(File o1, File o2) {
                if(Integer.parseInt(o1.getName())>Integer.parseInt(o2.getName())){
                    return 1;
                }
                return -1;

            }
        });

        //合并文件
        File mergeFile = new File("E:\\ffmpeg_test\\lucene_merge.avi");
        //创建新文件
        boolean newFile = mergeFile.createNewFile();

        //创建写对象
        RandomAccessFile raf_write = new RandomAccessFile(mergeFile,"rw");

        byte[] b = new byte[1024];
        for(File chunkFile:fileList){
            //创建一个读块文件的对象
            RandomAccessFile raf_read = new RandomAccessFile(chunkFile,"r");
            int len = -1;
            while((len = raf_read.read(b))!=-1){
                raf_write.write(b,0,len);
            }
            raf_read.close();
        }
        raf_write.close();
    }
}

```

**上传文件流程**

服务端需要实现如下功能： 

1、上传前检查上传环境 

检查文件是否上传，已上传则直接返回。 

检查文件上传路径是否存在，不存在则创建。 

2、分块检查 

检查分块文件是否上传，已上传则返回true。 

未上传则检查上传路径是否存在，不存在则创建。 

3、分块上传 

将分块文件上传到指定的路径。 

4、合并分块 

将所有分块文件合并为一个文件。 

在数据库记录文件信息。 

## 第十四天 媒资管理

视频处理的流程

![1582173334667](I:\张红亮\学成在线\学成在线笔记.assets\1582173334667-1584501760827.png)

新建视频处理工程xc-service-manage-media-processor

![1582173724018](G:\张红亮\学成在线\笔记图片\1582173724018.png)

```
ffmpeg是一个可行的视频处理程序，可以通过Java调用ffmpeg.exe完成视频处理。
在java中可以使用Runtime类和Process Builder类两种方式来执行外部程序，工作中至少掌握一种。
本项目使用Process Builder的方式来调用ffmpeg完成视频处理。
```

测试代码

```java
@SpringBootTest
@RunWith(SpringRunner.class)
public class TestProcessBuilder {

    //使用processBuilder来调用第三方应用程序
    @Test
    public void testProcessBuilder() throws IOException {
        //创建processBuilder对象
        ProcessBuilder processBuilder = new ProcessBuilder();
        //设置第三方应用程序的命令
//        processBuilder.command("ping","127.0.0.1");
        processBuilder.command("ipconfig");

        //将标准输入流和错误流合并
        processBuilder.redirectErrorStream(true);
        //启动一个进程
        Process process = processBuilder.start();

        //通过标准输入流来拿到正常和错误的信息
        InputStream inputStream = process.getInputStream();

        //转成字符流
        InputStreamReader reader = new InputStreamReader(inputStream,"gbk");
        //缓冲
        char[] chars = new char[1024];
        int len = -1;
        while ((len = reader.read(chars))!=-1){
            String string = new String(chars,0,len);
            System.out.println(string);
        }
        inputStream.close();
        reader.close();

    }

    @Test
    public void testFFmpeg() throws IOException {
        //创建processBuilder对象
        ProcessBuilder processBuilder = new ProcessBuilder();
        //设置第三方应用程序的命令
        List<String> command = new ArrayList<>();
        command.add("D:\\Program Files\\ffmpeg-20180227-fa0c9d6-win64-static\\bin\\ffmpeg.exe");
        command.add("-i");
        command.add("E:\\ffmpeg_test\\1.avi");
        command.add("-y");//覆盖输出文件
        command.add("-c:v");
        command.add("libx264");
        command.add("-s");
        command.add("1280x720");
        command.add("-pix_fmt");
        command.add("yuv420p");
        command.add("-b:a");
        command.add("63k");
        command.add("-b:v");
        command.add("753k");
        command.add("-r");
        command.add("18");
        command.add("E:\\ffmpeg_test\\1.mp4");
        processBuilder.command(command);

        //将标准输入流和错误流合并
        processBuilder.redirectErrorStream(true);
        //启动一个进程
        Process process = processBuilder.start();

        //通过标准输入流来拿到正常和错误的信息
        InputStream inputStream = process.getInputStream();

        //转成字符流
        InputStreamReader reader = new InputStreamReader(inputStream,"gbk");
        //缓冲
        char[] chars = new char[1024];
        int len = -1;
        while ((len = reader.read(chars))!=-1){
            String string = new String(chars,0,len);
            System.out.println(string);
        }
        inputStream.close();
        reader.close();

    }
	//测试工具类
    @Test
    public void testMp4VideoUtil(){
        //String ffmpeg_path, String video_path, String mp4_name, String mp4folder_path
        String ffmpeg_path = "D:\\Program Files\\ffmpeg-20180227-fa0c9d6-win64-static\\bin\\ffmpeg.exe";
        String video_path = "E:\\ffmpeg_test\\1.avi";
        String mp4_name = "1.mp4";
        String mp4folder_path = "E:\\ffmpeg_test\\";
        Mp4VideoUtil mp4VideoUtil = new Mp4VideoUtil(ffmpeg_path,video_path,mp4_name,mp4folder_path);
        //生成mp4
        String result = mp4VideoUtil.generateMp4();
        System.out.println(result);
    }
}

```

消息监听者用一个@RabbitListener注解实现

```java
@RabbitListener(queues = "${xc‐service‐manage‐media.mq.queue‐media‐processtask}")
public void receiveMediaProcessTask(String msg) throws IOException {
Map msgMap = JSON.parseObject(msg, Map.class);
LOGGER.info("receive media process task msg :{} ",msgMap);
```

发送消息在media工程中上传文件的代码那里

发消息的代码

```java
	 @Autowired
    RabbitTemplate rabbitTemplate;
public ResponseResult sendProcessVideoMsg(String mediaId){

        //查询数据库mediaFile
        Optional<MediaFile> optional = mediaFileRepository.findById(mediaId);
        if(!optional.isPresent()){
            ExceptionCast.cast(CommonCode.FAIL);
        }
        //构建消息内容
        Map<String,String> map = new HashMap<>();
        map.put("mediaId",mediaId);
        String jsonString = JSON.toJSONString(map);
        //向MQ发送视频处理消息
        try {
            rabbitTemplate.convertAndSend(RabbitMQConfig.EX_MEDIA_PROCESSTASK,routingkey_media_video,jsonString);
        } catch (AmqpException e) {
            e.printStackTrace();
            return new ResponseResult(CommonCode.FAIL);
        }

        return new ResponseResult(CommonCode.SUCCESS);
    }
```

mq的bean配置类

```java
@Configuration
public class RabbitMQConfig {

    public static final String EX_MEDIA_PROCESSTASK = "ex_media_processor";

    //视频处理路由
    @Value("${xc-service-manage-media.mq.routingkey-media-video}")
    public  String routingkey_media_video;

    //消费者并发数量
    public static final int DEFAULT_CONCURRENT = 10;


    /**
     * 交换机配置
     * @return the exchange
     */
    @Bean(EX_MEDIA_PROCESSTASK)
    public Exchange EX_MEDIA_VIDEOTASK() {
        return ExchangeBuilder.directExchange(EX_MEDIA_PROCESSTASK).durable(true).build();
    }

}
```

配置文件

xc-service-manage-media:
  upload-location: F:/develop/video/
  mq:
    routingkey-media-video: routingkey_media_video

## 第十五天 媒资管理系统集成

学习页面获取视频url

业务流程如下：

![1582203819427](G:\张红亮\学成在线\笔记图片\1582203819427.png)

```
业务流程说明：
1、用户进入在线学习页面，页面请求搜索服务获取课程信息（包括课程计划信息）并且在页面展示。
2、在线学习请求学习服务获取视频播放地址。
3、学习服务校验当前用户是否有权限学习，如果没有权限学习则提示用户。
4、学习服务校验通过，请求搜索服务获取课程媒资信息。
5、搜索服务请求ElasticSearch获取课程媒资信息。

为什么要请求ElasticSearch查询课程媒资信息？
出于性能的考虑，公开查询课程信息从搜索服务查询。
什么时候将课程媒资信息存储到ElasticSearch中？
课程媒资信息是在课程发布的时候存入ElasticSearch，因为课程发布后课程信息将基本不再修改。
```

课程媒资信息是在课程发布的时候存入ElasticSearch索引库，因为课程发布后课程信息将基本不再修改，

新建一张teachplan_media_pub表，其实就是teachplan_media表加上时间戳字段用来给logstash采集数据

具体的 业务流程如下。 

```
1、课程发布，向课程媒资信息表写入数据。
1）根据课程id删除teachplanMediaPub中的数据
2）根据课程id查询teachplanMedia数据
3）将查询到的teachplanMedia数据插入到teachplanMediaPub中
2、Logstash定时扫描课程媒资信息表，并将课程媒资信息写入索引库。
```

在添加课程的service方法中发布课程成功后，添加课程媒资信息的索引

```java
//保存课程计划媒资信息
private void saveTeachplanMediaPub(String courseId){
//查询课程媒资信息
List<TeachplanMedia> teachplanMediaList = teachplanMediaRepository.findByCourseId(courseId);
//将课程计划媒资信息存储待索引表
teachplanMediaPubRepository.deleteByCourseId(courseId);
List<TeachplanMediaPub> teachplanMediaPubList = new ArrayList<>();
for(TeachplanMedia teachplanMedia:teachplanMediaList){
TeachplanMediaPub teachplanMediaPub =new TeachplanMediaPub();
BeanUtils.copyProperties(teachplanMedia,teachplanMediaPub);
teachplanMediaPubList.add(teachplanMediaPub);
}
teachplanMediaPubRepository.saveAll(teachplanMediaPubList);
}
```

```java
修改课程发布的service方法：
....
//保存课程计划媒资信息到待索引表
saveTeachplanMediaPub(courseId);
//页面url
String pageUrl = cmsPostPageResult.getPageUrl();
return new CoursePublishResult(CommonCode.SUCCESS,pageUrl);
.....
```

ES创建创建xc_course_media索引库，并根据上面pub表的字段创建映射

## 第十六天   认证相关

用户认证，用户授权、单点登录、第三方认证。身份认证通过后才身份授权

#### 单点登录

**Oauth2**协议

![1582367360949](G:\张红亮\学成在线\笔记图片\1582367360949.png)

Oauth2有以下授权模式： 

授权码模式（Authorization Code） 隐式授权模式（Implicit） 密码模式（Resource Owner Password 

Credentials） 客户端模式（Client Credentials） 

其中授权码模式和密码模式应用较多

##### **授权码授权流程**

1、客户端请求第三方授权

 2、用户(资源拥有者)同意给客户端授权 

3、客户端获取到授权码，请求认证服务器申请 

令牌

 4、认证服务器向客户端响应令牌

 5、客户端请求资源服务器的资源，资源服务校验令牌合法性，完成授权 

6、资源服务器返回受保护资源

![1582369223680](G:\张红亮\学成在线\笔记图片\1582369223680.png)

![1582369430328](G:\张红亮\学成在线\笔记图片\1582369430328.png)

令牌是授权服务用一个私钥产生的，那些课程服务，媒资服务等都属于资源服务，要把他们接入授权系统，然后拿着上一步形成的私钥对资源服务的公钥，对上了才能认证成功，才能访问资源服务

把以前的工程改造成资源服务（也就是加入认证系统）的步骤：

1、配置公钥  

将公钥拷贝到 publickey.txt文件中，将此文件拷贝到资源服务工程的classpath下

2、添加依赖

```
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>spring‐cloud‐starter‐oauth2</artifactId>
</dependency>
```

3、在confifig包下创建ResourceServerConfifig类：



**解决swagger-ui无法访问**

在上边第三步的ResourceServerConfifig类中加入下边代码放行，但是也就是只能登陆，不能进行单元测试

```java
//Http安全配置，对每个到达系统的http请求链接进行校验
@Override
public void configure(HttpSecurity http) throws Exception {
//所有请求必须认证通过
http.authorizeRequests()
//下边的路径放行
.antMatchers("/v2/api‐docs", "/swagger‐resources/configuration/ui",
"/swagger‐resources","/swagger‐resources/configuration/security",
"/swagger‐ui.html","/webjars/**").permitAll()
.anyRequest().authenticated();
}
```

##### 密码模式

就是在user表里查到了用户名和密码对上了就颁发令牌



**刷新令牌**

grant_type： 固定为 refresh_token 

refresh_token：刷新令牌（注意不是access_token，而是refresh_token） 

申请令牌的时候会附带一个刷新令牌，作用就是快过期的时候不用用户再输入账号密码系统帮用户再申请到新的令牌继续让他处于登录状态

#### JWT

上面介绍的认证方法性能不高，因为每次校验合法性都需要资源服务通过网络调用认证服务，中间有网络请求

JWT是让资源服务自己就可以校验令牌合法性，性能高

![1582371685571](G:\张红亮\学成在线\笔记图片\1582371685571.png)

**JWT令牌结构**

1、Header    头

头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA） 

一个例子如下： 

下边是Header部分的内容

{ 

"alg": "HS256", 

"typ": "JWT" 

} 

将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。

2、Payload   负载

可以自行扩充编写，也是Base64编码

3、Signature   签名

第三部分是签名，此部分用于防止jwt内容被篡改。 

这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明 

签名算法进行签名。 

**生成私钥和公钥**（私钥创建的令牌公钥可以去校验，认证服务里的是私钥用来生成jwt令牌，各个资源服务里的是公钥用来校验令牌）

在dos窗口运行下边命令生成

![1582372458690](G:\张红亮\学成在线\笔记图片\1582372458690.png)

![1582372572120](G:\张红亮\学成在线\笔记图片\1582372572120.png)

把生成的xc.keystore秘钥文件放到认证服务的classpath下

用一个工具导出xc.keystore文件里的公钥，放到资源服务里

##### 测试生成和校验jwt令牌

```java
//生成一个jwt令牌
@Test
public void testCreateJwt(){
//证书文件
String key_location = "xc.keystore";
//密钥库密码
String keystore_password = "xuechengkeystore";
//访问证书路径
ClassPathResource resource = new ClassPathResource(key_location);
//密钥工厂
KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(resource,
keystore_password.toCharArray());
//密钥的密码，此密码和别名要匹配
String keypassword = "xuecheng";
//密钥别名
String alias = "xckey";
//密钥对（密钥和公钥）
KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias,keypassword.toCharArray());
//私钥
RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate();
//定义payload信息
Map<String, Object> tokenMap = new HashMap<>();
tokenMap.put("id", "123");
tokenMap.put("name", "mrt");
tokenMap.put("roles", "r01,r02");
tokenMap.put("ext", "1");
//生成jwt令牌
Jwt jwt = JwtHelper.encode(JSON.toJSONString(tokenMap), new RsaSigner(aPrivate))
 //取出jwt令牌
String token = jwt.getEncoded();
System.out.println("token="+token);
}


//资源服务使用公钥验证jwt的合法性，并对jwt解码
@Test
public void testVerify(){
//jwt令牌
String token
="eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHQiOiIxIiwicm9sZXMiOiJyMDEscjAyIiwibmFtZSI6Im1ydCIsI
mlkIjoiMTIzIn0.KK7_67N5d1Dthd1PgDHMsbi0UlmjGRcm_XJUUwseJ2eZyJJWoPP2IcEZgAU3tUaaKEHUf9wSRwaDgwhrw
fyIcSHbs8oy3zOQEL8j5AOjzBBs7vnRmB7DbSaQD7eJiQVJOXO1QpdmEFgjhc_IBCVTJCVWgZw60IEW1_Lg5tqaLvCiIl26K
48pJB5f‐le2zgYMzqR1L2LyTFkq39rG57VOqqSCi3dapsZQd4ctq95SJCXgGdrUDWtD52rp5o6_0uq‐
mrbRdRxkrQfsa1j8C5IW2‐T4eUmiN3f9wF9JxUK1__XC1OQkOn‐ZTBCdqwWIygDFbU7sf6KzfHJTm5vfjp6NIA";
//公钥
String publickey = "‐‐‐‐‐BEGIN PUBLIC KEY‐‐‐‐‐
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAijyxMdq4S6L1Af1rtB8SjCZHNgsQG8JTfGy55eYvzG0B/E4AudR2
prSRBvF7NYPL47scRCNPgLnvbQczBHbBug6uOr78qnWsYxHlW6Aa5dI5NsmOD4DLtSw8eX0hFyK5Fj6ScYOSFBz9cd1nNTvx
2+oIv0lJDcpQdQhsfgsEr1ntvWterZt/8r7xNN83gHYuZ6TM5MYvjQNBc5qC7Krs9wM7UoQuL+s0X6RlOib7/mcLn/lFLsLD
dYQAZkSDx/6+t+1oHdMarChIPYT1sx9Dwj2j2mvFNDTKKKKAq0cv14Vrhz67Vjmz2yMJePDqUi0JYS2r0iIo7n8vN7s83v5u
OQIDAQAB‐‐‐‐‐END PUBLIC KEY‐‐‐‐‐";
//校验jwt
Jwt jwt = JwtHelper.decodeAndVerify(token, new RsaVerifier(publickey));
//获取jwt原始内容
String claims = jwt.getClaims();
//jwt令牌
String encoded = jwt.getEncoded();
System.out.println(encoded);
}
```

#### 登录开发

/*测试时不想那个路径必须携带令牌就可以访问可以在资源服务的config文件夹下的文件里排除这个路径，代码如下*/

```java
 //Http安全配置，对每个到达系统的http请求链接进行校验
    @Override
    public void configure(HttpSecurity http) throws Exception {
        //所有请求必须认证通过
        http.authorizeRequests()
                //下边的路径放行
                .antMatchers("/v2/api-docs", "/swagger-resources/configuration/ui",
                        "/swagger-resources","/swagger-resources/configuration/security",
                        "/swagger-ui.html","/webjars/**","/course/coursepic/list/**").permitAll()
                .anyRequest().authenticated();
    }
```

![1582373834527](G:\张红亮\学成在线\笔记图片\1582373834527.png)

```
执行流程：
1、用户登录，请求认证服务
2、认证服务认证通过，生成jwt令牌，将jwt令牌及相关信息写入Redis，并且将身份令牌写入cookie（身份令牌是和jwt令牌对应的一个简短的令牌，cookie里放jwt令牌的话太长了不方便）
3、用户访问资源页面，带着cookie到网关
4、网关从cookie获取token，并查询Redis校验token,如果token不存在则拒绝访问，否则放行
5、用户退出，请求认证服务，清除redis中的token，并且删除cookie中的token
使用redis存储用户的身份令牌有以下作用：
1、实现用户退出注销功能，服务端清除令牌后，即使客户端请求携带token也是无效的。
2、由于jwt令牌过长，不宜存储在cookie中，所以将jwt令牌存储在redis，由客户端请求服务端获取并在客户端存
储。
```

![1582374589253](G:\张红亮\学成在线\笔记图片\1582374589253.png)

认证服务需要实现的功能如下： 

1、登录接口 

前端post提交账号、密码等，用户身份校验通过，生成令牌，并将令牌存储到redis。 

将令牌写入cookie。 

2、退出接口 

校验当前用户的身份为合法并且为已登录状态。 

将令牌从redis删除。 

删除cookie中的令牌。 

实现看代码

## 第十七天  用户认证 Zuul

![1582425168138](G:\张红亮\学成在线\笔记图片\1582425168138.png)

认证服务校验用户名密码通过后将三个令牌存到redis，给客户端返回token携带短的身份令牌，客户端要请求服务资源要拿着身份令牌查出jwt令牌放到头信息中，这样资源服务拿到头信息里的jwt令牌进行身份校验

```
业务流程说明如下：
1、客户端请求认证服务进行认证。
2、认证服务认证通过向浏览器cookie写入token(身份令牌)
认证服务请求用户中心查询用户信息。
认证服务请求Spring Security申请令牌。
认证服务将token(身份令牌)和jwt令牌存储至redis中。
认证服务向cookie写入 token(身份令牌)。
3、前端携带token请求认证服务获取jwt令牌
前端获取到jwt令牌并存储在sessionStorage。
前端从jwt令牌中解析中用户信息并显示在页面。
4、前端携带cookie中的token身份令牌及jwt令牌访问资源服务
前端请求资源服务需要携带两个token，一个是cookie中的身份令牌，一个是http header中的jwt令牌
前端请求资源服务前在http header上添加jwt请求资源
5、网关校验token的合法性
用户请求必须携带token身份令牌和jwt令牌
网关校验redis中token是否合法，已过期则要求用户重新登录
6、资源服务校验jwt的合法性并完成授权
资源服务校验jwt令牌，完成授权，拥有权限的方法正常执行，没有权限的方法将拒绝访问。
```



以前UserDetailsServiceImpl.java里的用户名密码查询是写死的，现在新建用户中心工程xc-service-ucenter，具体实现见代码和讲义

ucenter工程的查询数据库用户名密码的接口写好后要在auth工程里的UserDetailsServiceImpl.java中进行远程调用

ucenter的controller：

```java
@RestController
@RequestMapping("/ucenter")
public class UcenterController implements UcenterControllerApi {
    @Autowired
    UserService userService;

    @Override
    @GetMapping("/getuserext")
    public XcUserExt getUserext(@RequestParam("username") String username) {
        return userService.getUserExt(username);
    }
}
```

auth工程要写一个client，其实就是一个接口，feign可以生成代理对象

```java
@FeignClient(value = XcServiceList.XC_SERVICE_UCENTER)
public interface UserClient {
    //根据账号查询用户信息
    @GetMapping("/ucenter/getuserext")
    public XcUserExt getUserext(@RequestParam("username") String username);
}
```

然后在service里注入这个接口就可以使用了



#### 前端显示登录人信息

登录成功后到首页，cookie里有短的身份令牌，根据这个请求认证服务获得jwt令牌，jwt里包含着用户信息，解析处理在页面显示即可

![1582429210906](G:\张红亮\学成在线\笔记图片\1582429210906.png)

controller：

```java
 @Override
    @GetMapping("/userjwt")
    public JwtResult userjwt() {
        //取出cookie中的用户身份令牌
        String uid = getTokenFormCookie();
        if(uid == null){
            return new JwtResult(CommonCode.FAIL,null);
        }

        //拿身份令牌从redis中查询jwt令牌
        AuthToken userToken = authService.getUserToken(uid);
        if(userToken!=null){
            //将jwt令牌返回给用户
            String jwt_token = userToken.getJwt_token();
            return new JwtResult(CommonCode.SUCCESS,jwt_token);
        }
        return null;
    }

    //取出cookie中的身份令牌
    private String getTokenFormCookie(){
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        Map<String, String> map = CookieUtil.readCookie(request, "uid");
        if(map!=null && map.get("uid")!=null){
            String uid = map.get("uid");
            return uid;
        }
        return null;
    }
```

service：

```java
//从redis查询令牌
    public AuthToken getUserToken(String token){
        String key = "user_token:" + token;
        //从redis中取到令牌信息
        String value = stringRedisTemplate.opsForValue().get(key);
        //转成对象
        try {
            AuthToken authToken = JSON.parseObject(value, AuthToken.class);
            return authToken;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

    }
```

#### Zuul网关

搭建工程：

先导入

启动类的注解

```java
@SpringBootApplication
@EnableZuulProxy
public class GatewayApplication {
public static void main(String[] args) {
SpringApplication.run(GatewayApplication.class, args);
}
}
```

注意zuul也要导入eurkea client的坐标，因为他要知道eurkea的服务列表

##### 配置路由：

yml文件中

```
zuul:
	routes:
		manage‐course: #路由名称，名称任意，保持所有路由名称唯一
		path: /course/**
		serviceId: xc‐service‐manage‐course #指定服务id，从Eureka中找到服务的ip和端口
		#url: http://localhost:31200 #也可指定url
		strip‐prefix: false #true：代理转发时去掉前缀，false:代理转发时不去掉前缀
		sensitiveHeaders: #默认zuul会屏蔽cookie，cookie不会传到下游服务，这里设置为空则取消默认的黑								名单，如果设置了具体的头信息则不会传到下游服务
		# ignoredHeaders: Authorization
```

serviceId：推荐使用serviceId，zuul会从Eureka中找到服务id对应的ip和端口。 

strip-prefifix: false #true：代理转发时去掉前缀，false:代理转发时不去掉前缀，例如，为true请 

求/course/coursebase/get/..，代理转发到/coursebase/get/，如果为false则代理转到/course/coursebase/get 

sensitiveHeaders：敏感头设置，默认会过虑掉cookie，这里设置为空表示不过虑 

ignoredHeaders：可以设置过虑的头信息，默认为空表示不过虑任何头 

##### 过滤器

Zuul的核心就是过虑器，通过过虑器实现请求过虑，身份校验等。 

**4.5.1 ZuulFilter** 

自定义过虑器需要继承 ZuulFilter，ZuulFilter是一个抽象类，需要覆盖它的四个方法，如下： 

1、 shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true表示要执行此过虑器，否则不执 

行。 

2、 run：过滤器的业务逻辑。 

3、 fifilterType：返回字符串代表过滤器的类型，如下 pre：请求在被路由之前 

执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 

4、 fifilterOrder：此方法返回整型数值，通过此数值来定义过滤器的执行顺序，数字越小优先级越高。 

测试代码：记得标@Component注解

```java
@Component
public class LoginFilterTest extends ZuulFilter {
private static final Logger LOG = LoggerFactory.getLogger(LoginFilterTest.class);
@Override
public String filterType() {
return "pre";
}
@Override
public int filterOrder() {
return 2;//int值来定义过滤器的执行顺序，数值越小优先级越高
}
@Override
public boolean shouldFilter() {// 该过滤器需要执行
return true;
}
@Override
public Object run() {
RequestContext requestContext = RequestContext.getCurrentContext();
HttpServletResponse response = requestContext.getResponse();
HttpServletRequest request = requestContext.getRequest();
//取出头部信息Authorization
String authorization = request.getHeader("Authorization");
if(StringUtils.isEmpty(authorization)){
requestContext.setSendZuulResponse(false);// 拒绝访问
requestContext.setResponseStatusCode(200);// 设置响应状态码
ResponseResult unauthenticated = new ResponseResult(CommonCode.UNAUTHENTICATED);
String jsonString = JSON.toJSONString(unauthenticated);
requestContext.setResponseBody(jsonString);
requestContext.getResponse().setContentType("application/json;charset=UTF‐8");
return null;
}
return null;
}
}
```

**zull实现身份校验：**

本小节实现网关连接Redis校验令牌： 

1、从cookie查询用户身份令牌是否存在，不存在则拒绝访问 

2、从http header查询jwt令牌是否存在，不存在则拒绝访问

3、从Redis查询user_token令牌是否过期，过期则拒绝访问

filter：

```java
package com.xuecheng.govern.gateway.filter;

import com.alibaba.fastjson.JSON;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import com.xuecheng.framework.model.response.CommonCode;
import com.xuecheng.framework.model.response.ResponseResult;
import com.xuecheng.govern.gateway.service.AuthService;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/** 身份校验过虑器
 * @author Administrator
 * @version 1.0
 **/

@Component
public class LoginFilter extends ZuulFilter {

    @Autowired
    AuthService authService;

    //过虑器的类型
    @Override
    public String filterType() {
        /**
         pre：请求在被路由之前执行

         routing：在路由请求时调用

         post：在routing和errror过滤器之后调用

         error：处理请求时发生错误调用

         */
        return "pre";
    }

    //过虑器序号，越小越被优先执行
    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        //返回true表示要执行此过虑器
        return true;
    }

    //过虑器的内容
    //测试的需求：过虑所有请求，判断头部信息是否有Authorization，如果没有则拒绝访问，否则转发到微服务。
    @Override
    public Object run() throws ZuulException {
        RequestContext requestContext = RequestContext.getCurrentContext();
        //得到request
        HttpServletRequest request = requestContext.getRequest();
        //得到response
        HttpServletResponse response = requestContext.getResponse();
        //取cookie中的身份令牌
        String tokenFromCookie = authService.getTokenFromCookie(request);
        if(StringUtils.isEmpty(tokenFromCookie)){
            //拒绝访问
            access_denied();
            return null;
        }
        //从header中取jwt
        String jwtFromHeader = authService.getJwtFromHeader(request);
        if(StringUtils.isEmpty(jwtFromHeader)){
            //拒绝访问
            access_denied();
            return null;
        }
        //从redis取出jwt的过期时间
        long expire = authService.getExpire(tokenFromCookie);
        if(expire<0){
            //拒绝访问
            access_denied();
            return null;
        }

        return null;
    }


    //拒绝访问
    private void access_denied(){
        RequestContext requestContext = RequestContext.getCurrentContext();
        //得到response
        HttpServletResponse response = requestContext.getResponse();
        //拒绝访问
        requestContext.setSendZuulResponse(false);
        //设置响应代码
        requestContext.setResponseStatusCode(200);
        //构建响应的信息
        ResponseResult responseResult = new ResponseResult(CommonCode.UNAUTHENTICATED);
        //转成json
        String jsonString = JSON.toJSONString(responseResult);
        requestContext.setResponseBody(jsonString);
        //转成json，设置contentType
        response.setContentType("application/json;charset=utf-8");
    }


}

```

service：

```java
package com.xuecheng.govern.gateway.service;

import com.xuecheng.framework.utils.CookieUtil;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * @author Administrator
 * @version 1.0
 **/
@Service
public class AuthService {

    @Autowired
    StringRedisTemplate stringRedisTemplate;

    //从头取出jwt令牌
    public String getJwtFromHeader(HttpServletRequest request){
        //取出头信息
        String authorization = request.getHeader("Authorization");
        if(StringUtils.isEmpty(authorization)){
            return null;
        }
        if(!authorization.startsWith("Bearer ")){
            return null;
        }
        //取到jwt令牌
        String jwt = authorization.substring(7);
        return jwt;


    }
    //从cookie取出token
    //查询身份令牌
    public String getTokenFromCookie(HttpServletRequest request){
        Map<String, String> cookieMap = CookieUtil.readCookie(request, "uid");
        String access_token = cookieMap.get("uid");
        if(StringUtils.isEmpty(access_token)){
            return null;
        }
        return access_token;
    }

    //查询令牌的有效期
     public long getExpire(String access_token){
        //key
         String key = "user_token:"+access_token;
         Long expire = stringRedisTemplate.getExpire(key, TimeUnit.SECONDS);
         return expire;
     }
}

```

## 第十八天 用户授权

方法授权

```java
@PreAuthorize("hasAuthority('course_find_list')")
@Override
public QueryResult<CourseInfo> findCourseList(@PathVariable("page") int page,
@PathVariable("size") int size,
CourseListRequest courseListRequest)
```

**资源服务添加授权控制** 

1、要想在资源服务使用方法授权，首先在资源服务配置授权控制 

1）添加spring-cloud-starter-oauth2依赖。 

2）拷贝授权配置类ResourceServerConfifig。 

3）拷贝公钥。 

2、在资源方法上添加访问权限注解

3、在资源服务（这里是课程管理）的ResourceServerConfifig类上添加注解，激活方法上添加授权注解

```
//激活方法上的PreAuthorize注解
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
```

细粒度授权框架不能解决，因为涉及到数据了，比如公司用户查询课程只能显示该公司的课程，

只能是，发放令牌的时候把用户所属公司的id放进去，请求资源服务的时候在令牌里解析出来公司id，根据公司id去数据库查这样就只是该公司的所属课程

**微服务之间认证**

用feign拦截器，调别的微服务时给带上header，也就是jwt

## 第十九天 分布式事务

分布式事务常见的三种形式

![1582521102224](G:\张红亮\学成在线\笔记图片\1582521102224.png)

![1582521116341](G:\张红亮\学成在线\笔记图片\1582521116341.png)

#### CAP理论

分布式系统能否兼顾C、A、P？ 

在保证分区容忍性的前提下一致性和可用性无法兼顾，如果要提高系统的可用性就要增加多个结点，如果要保证数 

据的一致性就要实现每个结点的数据一致，结点越多可用性越好，但是数据一致性越差。 

所以，在进行分布式系统设计时，同时满足“一致性”、“可用性”和“分区容忍性”三者是几乎不可能的。 

CAP有哪些组合方式？ 

1、CA：放弃分区容忍性，加强一致性和可用性，关系数据库按照CA进行设计。 

2、AP：放弃一致性，加强可用性和分区容忍性，追求最终一致性，很多NoSQL数据库按照AP进行设计。 

说明：这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允 

许暂时的数据不一致，只要最终在用户接受的时间内数据 一致即可。 

3、CP：放弃可用性，加强一致性和分区容忍性，一些强一致性要求的系统按CP进行设计，比如跨行转账，一次转 

账请求要等待双方银行系统都完成整个事务才算完成。 

说明：由于网络问题的存在CP系统可能会出现待等待超时，如果没有处理超时问题则整理系统会出现阻塞。 

总结： 在分布式系统设计中AP的应用较多，即保证分区容忍性和可用性，牺牲数据的强一致性（写操作后立刻读取到最 

新数据），保证数据最终一致性。比如：订单退款，今日退款成功，明日账户到账，只要在预定的用户可以接受的 

时间内退款事务走完即可。 

分布式事务解决方案：用消息队列

![1582531809310](G:\张红亮\学成在线\笔记图片\1582531809310.png)

```
1、支付成功后，订单服务向本地数据库更新订单状态并向消息表写入“添加选课消息”，通过本地数据库保证订单
状态和添加选课消息的事务。。
2、定时任务扫描消息表，取出“添加选课任务“并发向MQ。
3、学习服务接收到添加选课的消息，先查询本地数据库的历史消息表是否存在消息，存在则说明已经添加选课，
否则向本地数据库添加选课，并向历史消息表添加选课消息。这里选课表和历史消息表在同一个数据库，通过本地
事务保证。
4、学习服务接收到添加选课的消息，通过查询消息表判断如果已经添加选课也向MQ发送“完成添加选课任务的消
息”，否则则添加选课，完成后向MQ发送“完成添加选课任务的消息”，
5、订单服务接收到完成选课的消息后删除订单数据库中消息表的“添加选课消息”，为保证后期对账将消息表的消
息先添加到历史消息表再删除消息，表示此消息已经完成。
```

#### Spring Task定时任务

在Spring boot启动类上添加注解：@EnableScheduling 

新建任务测试类TestTask（这是只有一个线程，串行调度），编写测试方法如下：

```java
@Component
public class ChooseCourseTask {
private static final Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask.class);
// @Scheduled(fixedRate = 5000) //上次执行开始时间后5秒执行
// @Scheduled(fixedDelay = 5000) //上次执行完毕后5秒执行
// @Scheduled(initialDelay=3000, fixedRate=5000) //第一次延迟3秒，以后每隔5秒执行一次
@Scheduled(cron="0/3 * * * * *")//每隔3秒执行一次
public void task1(){
LOGGER.info("===============测试定时任务1开始===============");
try {
Thread.sleep(5000);
} catch (InterruptedException e) {
e.printStackTrace();
}
LOGGER.info("===============测试定时任务1结束===============");
}
```

cron表达式：

cron表达式包括6部分： 

秒（0~59） 分钟（0~59） 小时（0~23） 月中的天（1~31） 月（1~12） 周中的天 （填写MON，TUE，WED，THU，FRI，SAT,SUN，或数字1~7 1表示MON，依次类推） 

特殊字符介绍： 

“/”字符表示指定数值的增量 

“*”字符表示所有可能的值 

“-”字符表示区间范围 

"," 字符表示列举 

“？”字符仅被用于月中的天和周中的天两个子表达式，表示不指定值 

例子： 

0/3 * * * * * 每隔3秒执行 

0 0/5 * * * * 每隔5分钟执行 

0 0 0 * * * 表示每天0点执行 

0 0 12 ? * WEN 每周三12点执行 

0 15 10 ? * MON-FRI 每月的周一到周五10点 15分执行 

0 15 10 ? * MON,FRI 每月的周一和周五10点 15分执行 

**并行任务调度方法，要配置线程池**，这样上边的两个定时任务就可以并行执行了

```java
@Configuration
@EnableScheduling//这里加了这个注解启动类上就不用加了 
public class AsyncTaskConfig implements SchedulingConfigurer, AsyncConfigurer {
//线程池线程数量
private int corePoolSize = 5;
@Bean
public ThreadPoolTaskScheduler taskScheduler()
{
ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
scheduler.initialize();//初始化线程池
scheduler.setPoolSize(corePoolSize);//线程池容量
return scheduler;
}
@Override
public Executor getAsyncExecutor() {
Executor executor = taskScheduler();
return executor;
}
@Override
public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
return null;
}
@Override
public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {
scheduledTaskRegistrar.setTaskScheduler(taskScheduler());
}
}
```

spring jpa可以如下这样发送sql语句

```
//更新任务处理时间
@Modifying
@Query("update XcTask t set t.updateTime = :updateTime where t.id = :id ")
public int updateTaskTime(@Param(value = "id") String id,@Param(value = "updateTime")Date
updateTime);
```

乐观锁取任务

订单服务是部署成集群式的，有可能多个节点能取到任务，所以每个节点取任务的时候立刻把该条任务的版本号+1，这样就不会两个节点都能取到任务了



![1584502093260](/../1584502093260.png)

![1584509578806](/1584509578806.png)

![1584509622584](/../1584509622584.png)

![金婚就](/../定州到北京拼车.png)





















